#!/bin/bash

# BASH Addins - the library of custom scripts, functions and aliases for enhanced BASH scripting and Terminal usage.
# Started by Artto Aunap (https://github.com/arrrtto) in 2025 for personal use, but in 2025 decided to share with the GNU/Linux and FOSS community.

# Best practice would be to keep one latest copy of this file in /home/$USER/bin folder, as then it would always be on the PATH and Terminal can see it.
# Usage: source bash.addins - or typically, after correct setup: source /home/$USER/bin/bash.addins
# If you run "bash.addins setup" then you will get everything set up, including adding the library file to the .bashrc file,
# so that it gets automatically loaded/imported every time Terminal is opened.


# ------------ INITIAL SETTINGS AND CHECKS ------------

# Current version. This is to be used for version check processes and usually updated by Artto or some other contributors of this library file
ba_version="1.02"

# Check the location where the bash.addins were executed from
ba_running_folder="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"



# ------------ ALIASES ------------ 

alias cls='clear'
alias distro='cat /etc/os-release'
alias grep='grep --color=auto'
alias installdeb='sudo dpkg -i'
alias ipaddress_local="echo $(ifconfig | grep broadcast | awk '{print $2}')"
alias ipaddress_public='wget https://ipinfo.io/ip -qO -'
alias findfile='find . -print | grep -i $2'
alias findtext_insidefiles='grep -r $1'
alias fixupdate='sudo apt install -f'
alias l='ls -CF'
alias la='ls -A'
alias ll='ls -alF'
alias lsdir="find . -maxdepth 1 -type d | sort | sed 's/.\///g'"            # List only folders in the current folder/directory, sorted A-Z
alias lsfiles="find . -maxdepth 1 -type f | sort | sed 's/.\///g'"            # List only files in the current folder/directory, sorted A-Z
alias lsfolders='lsdir'
alias mkdir='mkdir -p'                                                      # Create a folder only if it does not exist
alias setup='sudo dpkg -i'
alias showfunctions='showallfunctions'
alias update='sudo apt update && sudo apt -y upgrade'



# ------------ GENERAL GNU / BASH ------------

function showallfunctions() {
# Lists all the functions that the bash.addins contains.
local file=$(which bash.addins)
local RED='\033[0;31m'      # for function names
local LIGHT_GRAY='\033[0;37m'  # for comments
local NC='\033[0m'          # no Color

awk -v red="$RED" -v gray="$LIGHT_GRAY" -v nc="$NC" ' # Read the file and extract functions and comments
/^function/ {
    func_name = $2;  # Get the function name
    sub(/[(]/, "", func_name);  # Remove the ( from the function name
    sub(/[)]/, "", func_name);  # Remove the ) from the function name
    if (func_name ~ /^ba_/) next;  # Skip functions starting with "ba_"
    printf "%s%s%s\n", red, func_name, nc;  # Print the function name in red
    getline;  # Move to the next line
    while ($0 ~ /^#/) {  # While the line starts with #
        printf "%s%s%s\n", gray, $0, nc;  # Print the comment line in light gray
        getline;  # Move to the next line
    }
    print "";  # Print a blank line for separation
}
' "$file"
}


function showaliases() {
# Lists all the aliases that the bash.addins contains.
cat $(which bash.addins) | grep -E "alias "
}

function functions_amount(){
# Outputs the number of all available functions.
showallfunctions | grep -Ev "#" | sed_removeemptylines | wc -l
}

function reload() {
# Reloads the BASH Add-ins library file by executing: source bash.addins
source bash.addins
}

function all() {
# Lists all files in the current folder as a raw list, while skipping the folders.
# Example: ls | all
while IFS= read -r file; do [[ -f "$file" ]] && echo "$file"; done
}


function countdown_minutes() {
# Counts down from a specified number of minutes, displaying the remaining time.
# Example: countdown_minutes 5
count=${1?No parameters given. Try countdown_minutes 5}
(( ++count )) 
while (( --count >= 0 )); do
# using echo -ne and \r (carriage return) to overwrite the same line instead of printing a new one each time.
# The extra spaces ("  ") at the end ensure the previous text is fully cleared when the number shrinks.
  echo -ne "\r$count minutes left to wait.  "
  sleep 60
done
echo ""  # Move to a new line after the loop finishes
}


function randomnumber {
# Generates random number for you between your desired numbers, such as between 1 and 1500.
# Example: randomnumber 5 250
if [ -z "$1" ]; then
echo "Generates random number for you between your desired numbers, such as between 1 and 1500."
echo "Example usage: randomnumber 5 250"
return 1
fi
local min=$1
local max=$2
expr $min + $RANDOM % $max
}


function whatnext() {
# Waits for user input. Good to use after or before a certain process in a BASH script.
read -p "Do you want to continue? (y/n): " choice
case "$choice" in 
  y|Y ) 
    echo "Continuing...";;
  n|N ) 
    echo "Exiting..."
    exit 1;;
  * ) 
    echo "Invalid input. Please enter y or n."
    exit 1;;
esac
}


# ------------ SYSTEM RELATED ------------

function freememory() {
# Shows RAM memory information.
mem=$(free -h | grep Mem)
swap=$(free -h | grep Swap)

# Extract total and available memory values
total_mem=$(echo $mem | awk '{print $2}' | sed 's/Gi/ GB/')
available_mem=$(echo $mem | awk '{print $7}' | sed 's/Gi/ GB/')

# Extract total and free swap values
total_swap=$(echo $swap | awk '{print $2}' | sed 's/Gi/ GB/')
free_swap=$(echo $swap | awk '{print $4}' | sed 's/Gi/ GB/')

# Format and display the output
echo "Available RAM: $available_mem of $total_mem" | sed_comma2dot
echo "Available Swap: $free_swap of $total_swap" | sed_comma2dot
}


function freespace() {
# Shows free (available) disk space.
df -h | grep "^/" | grep -Ev "boot" | awk '{print "Free space on", $1":", $4"B"}'
}


function systeminfo() {
# Displays comprehensive system information, including OS details, RAM memory, CPU and disk usage.
clear
local RED='\033[0;31m'
local GREEN='\033[0;32m'
local YELLOW='\033[0;33m'
local BLUE='\033[0;34m'
local NC='\033[0m' # No Color

local cpu_model=$(lscpu | grep "Model name" | awk -F: '{print $2}' | xargs)
local install_date=$(ls -ld / | awk '{print $7".", $6, $8}')
local total_mem=$(free -h | grep Mem | awk '{print $2}' | sed 's/Gi/ GB/')
local available_mem=$(free -h | grep Mem | awk '{print $7}' | sed 's/Gi/ GB/')
local os_info=$(lsb_release -d | awk -F: '{print $2}' | xargs)
local os_version=$(lsb_release -d | awk -F: '{print $2}' | xargs | sed_keep_price)
local os_mint=$(lsb_release -d | grep -o 'Mint')
local kernel_version=$(uname -r)
local uptime_info=$(uptime -p)
local hostname_info=$(hostname)

curl -sX 'GET' "https://endoflife.date/api/v1/products/linuxmint" -H "accept: application/json" > /tmp/eolapi.json
releases=() && while read -r r; do releases+=("$r"); done < <(jq -r '.result.releases[].name' /tmp/eolapi.json)
counter="0"
for version_number in ${releases[@]}; do
 if [[ $version_number = $os_version ]]; then break; fi  # scan through the version numbers
 counter=$((counter + 1))
done

echo -e "${BLUE}Operating System:${NC} $os_info"
echo -e "${YELLOW}Installation Date:${NC} $install_date"
if [[ $version_number != "" ]] && [[ $os_mint == "Mint" ]]; then echo -e "${YELLOW}End of Support:${NC}" $(jq -r ".result.releases["$counter"].eolFrom" /tmp/eolapi.json); fi
echo -e "${YELLOW}Kernel Version:${NC} $kernel_version"
echo -e "${YELLOW}Uptime:${NC} $uptime_info"
echo -e "${YELLOW}Hostname:${NC} $hostname_info"
echo -e "${GREEN}CPU Model:${NC} $cpu_model"
echo -e "${GREEN}Total Memory:${NC} $total_mem | out of which $available_mem is available" | sed_comma2dot
echo -e "${BLUE}Disks:${NC}"
df -h | grep "^/" | grep -Ev "boot" | awk '{print $1" -", $2"B total", "|", $4"B free"}' | sed_comma2dot
echo
echo
if [[ -f /tmp/eolapi.json ]]; then rm /tmp/eolapi.json; fi  # delete the json file, if it exists
}


function bigfiles() {
# Finds and lists files in the current folder and subfolders that exceed a specified size.
# Example: bigfiles +1G
# Example: bigfiles +200M
if [ -z "$1" ]; then
echo "Finds and lists you all files in the current folder and subfolders, with your set minimum size."
echo "And it also sorts the list from the largest to smallest."
echo "Usage: bigfiles +SIZE[G|M|k]"
echo "Example: bigfiles +1G or bigfiles +500M or bigfiles 200k"
return 1
fi
find . -type f -size "$1" -exec du -h {} + 2>/dev/null | sort -hr
}


function replace_extension() {
# Replaces the file extension of all files with a specified old extension to a new extension.
# Example: replace_extension jpg.txt txt   ; that renames "jpg.txt" extension to "txt"
old_ext="$1"
new_ext="$2"
if [[ -z "$old_ext" || -z "$new_ext" ]]; then
echo "Usage example: replace_extension jpg.txt txt"
return 1
fi
shopt -s nullglob  # avoid literal glob if no match
for file in *."$old_ext"; do
base="${file%.$old_ext}"
new_file="${base}.${new_ext}"
mv -- "$file" "$new_file"
done
}


function replace_spaces() {
# Replaces spaces in filenames with underscores (_ characters) in a specified folder.
# Example: replace_spaces ~/Downloads
local folder=${1?No input given for the folder} # Check if the folder is empty
if [ -z "$folder" ]; then return 0; fi  # Do nothing if no folder is provided
folder="${folder%/}" # Normalize folder path by removing trailing slash if present. No need, but for perfection sake
find "$folder/" -maxdepth 1 -type f -iname "*" | while IFS= read -r file; do
if [[ "$file" =~ \  ]]; then new_name="${file// /_}"; mv "$file" "$new_name"; fi
done
}


function check_process() {
# Checks if a specified app (process) is running and outputs its status.
# Example: check_process brave    ; outputs "'$process' is running."
local process="$1"
if pgrep -x "$process" > /dev/null; then
  echo "$process is running"
else
  echo "$process is not running"
fi
}


function kill_process() {
# Kills a specified process by name.
# Example: kill_process chromium
pid=$(pgrep -f $1) # Find the PID of the given process
# Send a SIGTERM signal (graceful close)
if [[ ! -z "$pid" ]]; then kill -SIGTERM "$pid"; fi
}

function kill_zombieprocesses_chromium(){
# Kills/removes all the Chromium browser processes, including the zombie ones.
ps -eo pid,ppid,state,comm | awk '$3=="Z" && $4=="chromium" {print $2}' | sort -u | xargs -r kill -9
}


function wait4download() {
# Waits for a download to complete by checking for .crdownload files in the Downloads folder.
# Example: wait4download
DOWNLOAD_DIR="/home/$USER/Downloads"
tempfile=$(find "$DOWNLOAD_DIR" -name "*.crdownload" | head -n 1)    # Find the file with .crdownload extension (assuming only one active download)
if [ -n "$tempfile" ]; then    # Check if the download process has started (i.e., a .crdownload file exists)
  echo "Downloading... $tempfile"
finalfile="${tempfile%.crdownload}"    # Extract the expected final file name (remove .crdownload)
while [ -f "$tempfile" ]; do sleep 5; done    # Loop until the .crdownload file disappears and final file exists
if [ -f "$finalfile" ]; then    # Once loop exits, check if the final file exists
 echo "$finalfile downloaded!"
else
 echo "$finalfile cannot be found at all. Did it even get downloaded?"
fi
else
 echo "No .crdownload files found, so possibly nothing is downloading to Downloads folder at the moment."
fi
}



# ------------ GUI APPS ------------

function focus_window() {
# Brings a selected app window to the front, making it the active window.
# Example: focus_window chromium
xdotool search --onlyvisible --class $1 windowactivate && sleep 1
}

function minimize_app() {
# Minimizes a window of a specified application by name.
# Example: minimize_app chromium
xdotool search --name $1 windowminimize && sleep 1
}

function maximize_app() {
# Maximizes a window of a specified application by name.
# Example: maximize_app chromium
xdotool search --name $1 windowactivate windowsize 100% 100% && sleep 1
}

function get_window_info() {
# Gets info about the currently active window (application), including coordinates and size.
# The output will be written and also put into variables x, y, width and height.
# Good example: focus_window brave && get_window_info
window_id=$(xdotool getactivewindow)
xwininfo -id $window_id | awk '/Absolute upper-left X:/ { print "X: " $4 }'
xwininfo -id $window_id | awk '/Absolute upper-left Y:/ { print "Y: " $4 }'
xwininfo -id $window_id | awk '/Width:/ { print "Width: " $2 }'
xwininfo -id $window_id | awk '/Height:/ { print "Height: " $2 }'
x=$(xwininfo -id $window_id | awk '/Absolute upper-left X:/ { print $4 }')
y=$(xwininfo -id $window_id | awk '/Absolute upper-left Y:/ { print $4 }')
width=$(xwininfo -id $window_id | awk '/Width:/ { print $2 }')
height=$(xwininfo -id $window_id | awk '/Height:/ { print $2 }')
}


function screenshot_window() {
# Takes a screenshot of the active window and saves it to /home/$USER/Screenshots as 'scr_$date_time.png'
# Example: screenshot_window firefox
date_time=$(date +%d.%m.%Y-%H:%M)
local window=${1?Usage example: screenshot_window firefox}
focus_window $window
window_id=$(xdotool search --name --onlyvisible $window | head -n 1)
if [ -z "$window_id" ]; then
  echo "$window window not found or it is not open (the process is not running)."
  return 1
else
  mkdir -p /home/$USER/Screenshots_$window
  local output_file="/home/$USER/Screenshots_$window/scr_$date_time.png"
  cd 
  xwd -id "$window_id" | convert xwd:- "$output_file"
  echo "Screenshot saved to $output_file"
fi
}



# --------- REGULAR EXPRESSIONS (RegEx) -----------
# HOW TO USE THESE FUNCTIONS? With piping, of course!

function regex_email() {
# Extracts email addresses from input text.
# Example: cat source.html | regex_email
grep -E -o '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
}

function regex_links_https() {
# Extracts all https links addresses from input text.
# Example: cat source.html | regex_links_https
grep -E -o 'https?://[a-zA-Z0-9./?=_-]+'
}

function regex_htmltag() {
# Matches HTML tags in input text, such as <div class="container"> and <img src="image.png" />
# Example: cat index.html | regex_htmltag
grep -E -o '<[a-zA-Z][a-zA-Z0-9]*[^>]*>'
}

function regex_ipaddress() {
# Extracts IP addresses from input text.
# Example: some_text | regex_ipaddress
grep -E -o '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b'
}

function regex_price() {
# Extracts price values from input text.
# Example: echo "Cost: $456.68" | regex_price      ; outputs 456.68
sed 's/[^0-9.]//g'
}

function regex_number() {
# Extracts numeric values from input text.
# Example: echo "Cost: $ 456.68" | regex_number    ; outputs 456 and 68 on separate lines
# NB! Best to NOT use echo $456, because the first number after $ gets lost when using echo.
grep -E -o '[0-9]+'
}

function regex_phonenumber() {
# Extracts phone numbers from input text.
grep -E -o '(\+?[0-9]{1,3}[-. ]?)?(\(?[0-9]{2,4}\)?[-. ]?)?[0-9]{3,4}[-. ][0-9]{3,4}'
}

function regex_date() {
# Extracts various date formats like DD-MM-YYYY, YYYY/MM/DD, DD.MM.YYYY, etc.
# Example: echo "Date: 14.05.2022" | regex_date → 14.05.2022
grep -E -o '\b([0-9]{2,4})([./-])[0-9]{1,2}\2[0-9]{1,4}\b'
}


function regex_usernamehandle() {
# Extracts usernames or handles, which start with @ from input text.
# Example: echo "This is @my_user useraccount" | regex_usernamehandle
grep -E -o '@[a-zA-Z0-9_]+'
}

function regex_hashtag() {
# Extracts hashtags from input text.
# Example: echo "This is #cool stuff" | regex_hashtag
grep -E -o '#[a-zA-Z0-9_]+'
}

function regex_youtube_id() {
# Extracts YouTube video ID from YouTube links.
# Example: echo "https://www.youtube.com/watch?v=dQw4w9WgXcQ" | regex_youtube_id    ; → dQw4w9WgXcQ
# Example: echo "https://youtu.be/abcd1234567" | regex_youtube_id    ; → abcd1234567
sed -nE 's~.*(v=|vi=|be/|embed/|shorts/|/v/|/e/|watch\?v=)([a-zA-Z0-9_-]{11}).*~\2~p'
}

function regex_sha256() {
# Extracts SHA-256 hashes from input text.
# Example: some_text | regex_sha256
grep -E -o '\b[a-fA-F0-9]{64}\b'
}

function regex_bitcoin() {
# Extracts Bitcoin addresses from input text.
# Example: some_text | regex_bitcoin
grep -E -o '\b[13][a-km-zA-HJ-NP-Z1-9]{25,34}\b'
}

function regex_uuid() {
# Extracts UUIDs from input text.
# Example: some_text | regex_uuid
grep -E -o '\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\b'
}

function regex_sql() {
# Extracts SQL commands from input text.
# Example: some_text | regex_sql
grep -E -o '\b(SELECT|INSERT|UPDATE|DELETE)\b[^;]+;'
}


function sed_comma2dot() {
# Replaces commas with dots in input text.
# Example: echo "1,23" | sed_comma2dot
sed 's/,/./g'
}

function sed_dot2comma() {
# Replaces dots with commas in input text.
# Example: echo "1.23" | sed_dot2comma    ; result: 1,23
sed 's/./,/g'
}

function sed_space_removeextra() {
# Replaces multiple (white)spaces with one space.
# Example: echo "This    is some text" | sed_space_removeextra
sed 's/[[:space:]]\+/ /g'
}

function sed_space_trim() {
# Removes leading and trailing whitespaces.
sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

function sed_space_removeall() {
# Removes all whitespaces (Spaces, Tabs, Newlines)
sed ':a;N;$!ba;s/[[:space:]]//g'
}

function sed_keep_textandnumbers() {
# Filters out text characters and numbers from the input text.
sed 's/[^a-zA-Z0-9]//g'
}

function sed_keep_numbers() {
sed 's/[^0-9]//g'
}

function sed_keep_price() {
# Extracts price values from input text.
# Example: echo "Cost: $456.68" | sed_keep_price      ; outputs 456.68
# Alias function: regex_price
sed 's/[^0-9.]//g'
}

function sed_upper2lowercase() {
# Changes input text to all lower case letters.
# Example: echo "This is OuTStanding" | sed_upper2lowercase
sed 's/[A-Z]/\L&/g'
}

function sed_add2end() {
# Adds a suffix to each line.
# Example: echo -e "Line1\nLine2" | sed_add2end
# Output:
# Line1 [SUFFIX]
# Line2 [SUFFIX]
sed 's/$/ [SUFFIX]/'
}

function sed_removelastline() {
# Removes the last line in the input text.
sed '$d'
}

function sed_removefirstline() {
# Removes the first line in the input text.
sed '1d'
}

function sed_keeplastword() {
# Keeps only the last word (after whitespace).
# Example: echo "This is some text here" | sed_keeplastword    ; output is: here
sed -E 's/.*[[:space:]]//g'
}

function sed_addemptyline() {
# Adds a new blank line to the text input.
sed 'G' 
}

function sed_removeemptylines() {
# Removes all blank/empty lines in the text input.
sed '/./!d'
}

function sed_joinlines() {
# Removes "\n" "\r" from the end to join two lines into one, plus removes whitespaces from the end.
sed 's/\r//' | tr -d '\n' | sed 's/[ \t]*$//'
}

function sed_joinlines_commasep() {
# Removes \r, join lines with ", ", and removes trailing whitespaces.
sed 's/\r//' | tr '\n' ', ' | sed 's/[ \t]*,$//'
}

function sed_joinlines_semicolonsep() {
# Removes \r, join lines with ", ", and removes trailing whitespaces.
sed 's/\r//' | tr '\n' '; ' | sed 's/[ \t]*;$//'
}

function sed_cleantext() {
# Removes the weird metadata characters from the input text.
sed 's/\x1b\[[0-9;]*m//g'
}

function regex_keep_number() {
# Keeps only the numbers and dots (.) which are found from the input text.
# Example: echo "The price is 0.54 USD" | regex_keep_number    ; Output: 0.54
grep -oE "[0-9]+\.[0-9]+"
}

function regex_keep_numberof_decimals() {
# Keeps only a selected number of decimals after dot (.)
# Ex: echo "0.24005" | regex_keep_numberof_decimals 2
# Output: 0.24
local input
read -r input
local digits="${1:-2}"
echo "$input" | grep -oE "^[0-9]+\.[0-9]{1,$digits}"
}

function regex_until() {
# Deletes everything after a certain character.
# Example: echo "helloXworld" | regex_until "X"    ->    Output: hello
sed -e "s/$1.*//"
}

function regex_until_specialchar() {
# If input text contains special characters like / or &, then uses a different delimiter (| instead of /):
# Example: echo "some text & with" | regex_until_specialchar '&'    ; Output: some text
local char="$1"
sed "s|$char.*||"
}

function regex_awk_seen() {
# Skips the already seen outputs/text when going through the lines of text.
# The point is to not show duplicate lines, if these have already displayed once.
awk '!seen[$0]++'
}

function regex_awk_sum() {
# Adds numbers, that are outputted on lines of text, by summing them together.
# Very useful for calculating sums.
# Example: cat numbers.txt | regex_awk_sum
# If numbers.txt file contains "4.52" on the first line, and "2" on second line,
# then the output is the sum of them (4.52 + 2), in this case 6.52
awk '{sum+=$1} END {print sum}'
}

function regex_awk_remove_betweenwords() {
# Removes a part of the input text, that is between two defined words.
# Example: echo "This is some random text" | regex_awk_remove_betweenwords "This" "some"
# outputs to " random text"
local start=${1?Need the starting word and ending word}
local start="$1"
local end="$2"
awk -v s="$start" -v e="$end" '{gsub(s ".*" e, ""); print}'
}

function regex_awk_keep_betweenwords() {
# Keeps a part of the input text, starting with the first word and ending with the second.
# Example: echo "This is some random text" | regex_awk_keep_betweenwords "some" "text"
# outputs to: "some random text", so it keeps the beginning word and the ending word also.
local start=${1?Need the starting word and ending word}
local start="$1"
local end="$2"
awk "{match(\$0, /$start .*?$end/, m); if (m[0]) print m[0]}"
}


# Sorting down or up, based on the number and sorting based on column
# e.g. the input for sorting is looks like:
# Toivo,Teivas,34.03,Something
# Annika,Leivas,-54.00,Somethingelse
# then the column to be sorted by is 3, and separator is automatically set to ","

#| Function                          | Sort Order | Based On    | Result Starts With |
#| ---------------------------- | ------------ | ------------- | -------------------- |
#| `sortdown_colnum`         | Ascending  | Real values | Most negative      |
#| `sortup_colnum`             | Descending | Real values | Most positive      |
#| `sortdown_abs_colnum` | Ascending  | Abs values  | Closest to 0         |
#| `sortup_abs_colnum`   | Descending | Abs values  | Furthest from 0    |

function sortdown_colnum() {
# Sorts input data by a specified column in descending numerical order.
# Example: cat data.csv | sortdown_colnum 3    ; sorting based on the column number 3
local col=${1?Usage example: sortdown_colnum 3}
col="$1"
awk -F',' -v col="$col" '{ print $col "|" $0 }' | sort -t'|' -k1,1n | cut -d'|' -f2-
}

function sortup_colnum() {
# Sorts input data by a specified column in ascending numerical order.
# Example: cat data.csv | sortup_colnum 3    ; sorting based on the column number 3
local col=${1?Usage example: sortup_colnum 3}
col="$1"
awk -F',' -v col="$col" '{ print $col "|" $0 }' | sort -t'|' -k1,1nr | cut -d'|' -f2-
}

function sortdown_abs_colnum() {
# Sorts input data by a specified column in descending order, treating negative values as positive.
# Example: cat data.csv | sortdown_abs_colnum 3
local col=${1?Usage example: sortdown_abs_colnum 3}
col="$1"
awk -F',' -v col="$col" '{
  a = $col
  gsub(/-/, "", a)
  print a "|" $0
}' | sort -t'|' -k1,1n | cut -d'|' -f2-
}

function sortup_abs_colnum() {
# Sorts input data by a specified column in ascending order, treating negative values as positive.
# Example: cat data.csv | sortup_abs_colnum 3
local col=${1?Usage example: sortup_abs_colnum 3}
col="$1"
awk -F',' -v col="$col" '{
  a = $col
  gsub(/-/, "", a)
  print a "|" $0
}' | sort -t'|' -k1,1nr | cut -d'|' -f2-
}

function sort_col() {
# Sorts input data by a specified column number, either numerically or alphabetically, based on the mode (up or down).
# Example: cat data.csv | sort_col 2 up
local col=${1?Usage example: sort_col 3 up}
# sort_col 2 up - sorts A-Z, if used non-numerical, but words
# sort_col 2 down - sorts Z-A
# 
col="$1"
mode="$2"

awk -F',' -v col="$col" '
BEGIN { is_number=1 }
{
  field = $col
  # Check if its a number (handle negatives & decimals)
  if (field !~ /^-?[0-9]+(\.[0-9]+)?$/) {
    is_number = 0
  }
  data[NR] = $0
  fields[NR] = field
}
END {
  for (i = 1; i <= NR; i++) {
    val = fields[i]
    if (is_number && (mode == "upabs" || mode == "downabs")) {
      gsub(/-/, "", val)
    }
    if (is_number)
      printf("%20.10f|%s\n", val, data[i])
    else
      print val "|" data[i]
  }
}
' mode="$mode" | {
  case "$mode" in
    up|upabs)
      sort
      ;;
    down|downabs)
      sort -r
      ;;
    *)
      echo "Invalid mode: $mode" >&2
      return 1
      ;;
  esac
} | cut -d'|' -f2-
}





# ------------ AUDIO / VIDEO / IMAGE PROCESSING ------------

function exa() {
# Extracts a segment of audio from an input file between specified start and end times.
# Example: exa this.mp3 00:14:17 00:19:22

    if [ $# -ne 3 ]; then
        echo "Extracts a segment of audio from an input file between specified start and end times."
        echo "Usage: exa input_file start_time end_time"
        echo "Example: exa this.mp3 00:14:17 00:19:22"
        return 1
    fi
    input="$1"
    start="$2"
    end="$3"
    base="${input%.*}"       # Remove extension
    ext="${input##*.}"       # Get extension
    counter=1

    # Find next available filename
    while [ -e "${base}_clip_${counter}.mp3" ]; do counter=$((counter + 1)); done
    out="${base}_clip_${counter}.mp3"
    ffmpeg -i "$input" -ss "$start" -to "$end" -ar 44100 -ac 2 -ab 192k -f mp3 "$out"
}


function exc() {
# Extracts a segment of video or audio from an input file between specified start and end times.
# Example: exc this.mp4 00:14:17 00:19:22
    if [ $# -ne 3 ]; then
        echo "Extracts a segment of video or audio from an input file between specified start and end times."
        echo "Usage: exc input_file start_time end_time"
        echo "Example: exc this.mp4 00:14:17 00:19:22"
        return 1
    fi
    input="$1"
    start="$2"
    end="$3"
    base="${input%.*}"       # Remove extension
    ext="${input##*.}"       # Get extension
    counter=1

    # Find next available filename
    while [ -e "${base}_clip_${counter}.${ext}" ]; do counter=$((counter + 1)); done
    out="${base}_clip_${counter}.${ext}"
    ffmpeg -i "$input" -ss "$start" -to "$end" -c copy "$out"
}


function to_mp4() {
# Converts input video files to MP4 format with a specified bitrate.
# Example: ls *.mov | all | to_mp4 3000
if [[ $# -ne 1 ]]; then
echo "For converting all inputted video files to mp4 videos with your custom bitrate."
echo "Usage example for all mov files in current folder: ls *.mov | all | tomp4 3000"
echo "Usage example for one file: echo \"somevideo.mkv\" tomp4 3000"
echo "... converts the file(s) to mp4 with 3000 kbps and automatically 256kbps AAC audio."
return 1
fi
bitrate="$1"
files=()
while IFS= read -r file; do files+=("$file"); done   # Read all input into an array
total=${#files[@]}
count=0
for file in "${files[@]}"; do
count=$((count + 1))
output="${file%.*}.mp4"
echo -ne "\r[$count/$total] Converting: $file -> $output"
ffmpeg -loglevel error -y -i "$file" -c:v libx264 -b:v "${bitrate}k" -c:a aac -strict experimental -b:a 256k "$output"
echo -ne "\r[$count/$total] Done:   $file -> $output\n"
done
echo "All conversions complete!"
}


function to_gif() {
# Converts an input video file to GIF format.
# Example: echo "video file.mp4" | to_gif
if [[ $# -ne 1 ]]; then
echo "For converting inputted video file to GIF format."
echo "Usage example: echo \"video file.mp4\" | togif"
return 1
fi
while IFS= read -r file; do
output="${file%.*}.gif"
echo "Converting '$file' to '$output'..."
ffmpeg -t 10 -i "$file" -vf "fps=15,scale=640:-1:flags=lanczos" "$output"
done
}


function to_png() {
# Converts an input image file to PNG format.
# Example: echo "photo 1.jpg" | to_png
if [[ $# -ne 1 ]]; then
echo "For converting inputted image file to PNG format."
echo "Usage example: echo \"photo 1.jpg\" | topng"
return 1
fi
while IFS= read -r file; do
output="${file%.*}.png"
convert "$file" "$output"
done
}


function to_jpg() {
# Converts an input image file to JPG format.
# Example: echo "photo 1.png" | to_jpg
if [[ $# -ne 1 ]]; then
echo "For converting inputted image file to JPG format."
echo "Usage example: echo \"photo 1.png\" | tojpg"
return 1
fi
while IFS= read -r file; do
output="${file%.*}.jpg"
convert "$file" "$output"
done
}


function to_jpg_from_HEIC() {
# Converts an input HEIC image file to JPG format.
# Example: echo "photo 1.heic" | to_jpg_from_HEIC
if [[ $# -ne 1 ]]; then
echo "For converting inputted image file to JPG format."
echo "Usage example: echo \"photo 1.png\" | tojpg"
return 1
fi
while IFS= read -r file; do
output="${file%.*}.jpg"
heif-convert "$file" "$output"
done
}



function cutvideo() {
# Cuts a segment from a video file between specified start and end times.
# Example: cutvideo "filename.mp4" 00:00:05 00:02:00
if [[ $1 == "" ]]; then
 echo "Example usage: cutvideo \"filename.mp4\" 00:00:05 00:02:00"
else
 local file="$1"
 local starttime="$2"
 local endtime="$3"
 if [ -f "$file" ]; then
 ffmpeg -ss $starttime -i "$1" -to $endtime -c copy "cut_$filename"
 else
  echo "$file cannot be found. Doublecheck the filename and its path. Or if the file contains spaces, use the quote marks like this: cutvideo \"this file.mp4\""
 fi
fi
}

function cutaudio() {
# Cuts a segment from an audio file between specified start and end times.
# Example: cutaudio "filename.mp3" 00:00:05 00:02:00
if [[ $1 == "" ]]; then
 echo "Example usage: cutaudio \"filename.mp3\" 00:00:05 00:02:00"
else
 local file="$1"
 local starttime="$2"
 local endtime="$3"
 if [ -f "$file" ]; then
 ffmpeg -ss $starttime -i "$1" -to $endtime -c copy "cut_$filename"
 else
  echo "$file cannot be found. Doublecheck the filename and its path. Or if the file contains spaces, use the quote marks like this: cutvideo \"this file.mp3\""
 fi
fi
}


function toclipboard() {
# Copies variable content, text, image or file contents to the clipboard, ready to be pasted (with Ctrl+V).
# Example for text: echo "Hello, World!" | toclipboard
# Example for image: ls zoom.png | toclipboard

input=$(cat)     # Read input from stdin or a pipe
if [[ -f "$input" ]]; then    # Check if the input is a file and exists
case "$input" in
    *.png)
        xclip -selection clipboard -t image/png -i "$input"
        ;;
    *.jpg | *.jpeg)
        convert "$input" png:- | xclip -selection clipboard -t image/png
        ;;
    *.mp4 | *.MP4)
        echo -n "$input" | xclip -selection clipboard    # Copy the file path to clipboard
        ;;
    *)
        xclip -selection clipboard -i "$input"   # Copy file contents to clipboard as text
        ;;
esac
else
echo "$input" | xclip -selection clipboard   # If it's not a file, copy the input as plain text
fi
}




# ------------ IMAGE PROCESSING ----------------

function generateQR() {
# Generates a QR code image file from input text.
# Usage: generateQR "https://qortal.dev"
# Outputs the file to Home folder as QR.png
# Pro Tip: generateQR "https://qortal.dev" | ls /home/$USER/QR.png | toclipboard
# This puts the generated QR code image to the Clipboard, ready to be pasted :)
if [[ $# -ne 1 ]]; then
echo "For generating QR code out of any text or input. The generated QR-code image file (QR.png) will end up in your home folder."
echo "Usage example: generateQR \"https://qortal.dev\""
return 1
fi
qrencode -o /home/$USER/QR.png -s 15 "$1"
echo "Generated /home/$USER/QR.png"
}


function scan_jpg() {
# Scans from a connected scanner into JPG image file.
# Output files end up in Scanned folder (under your Home folder).
mkdir -p /home/$USER/Scanned
date_time=$(date +"%d.%m_%H:%M:%S")
filename="/home/$USER/Scanned/$date_time"
scanimage --resolution 300 --mode Color --format=pnm > /tmp/scanned_image.pnm
sleep 1
convert /tmp/scanned_image.pnm $filename.jpg
}

function scan_pdf() {
# Scans from a connected scanner into PDF image file.
# Output files end up in Scanned folder (under your Home folder).
mkdir -p /home/$USER/Scanned
date_time=$(date +"%d.%m_%H:%M:%S")
failinimi="/home/$USER/Scanned/$date_time"
scanimage --resolution 300 --mode Color --format=pnm > /tmp/scanned_image.pnm
sleep 1
convert /tmp/scanned_image.pnm $filename.pdf
}


function pdf_rotate_clockwise() {
# Rotates a PDF file clockwise.
# Example: pdf_rotate_clockwise "document.pdf"
local file=${1?Usage example: pdf_rotate_clockwise "document.pdf"}
gs -o "rotated_$1" -sDEVICE=pdfwrite -c "<</Orientation 3>> setpagedevice" -f "$1"
}

function pdf_rotate_allinfolder_clockwise() {
# Rotates all PDF files in the current folder clockwise.
# Example: PDF_rotate_allinfolder_clockwise
for file in *.pdf; do gs -o "$file" -sDEVICE=pdfwrite -c "<</Orientation 3>> setpagedevice" -f "$file"; done
}

function pdf_compress_allinfolder() {
# Compresses all PDF files in the current folder.
# Example: PDF_compress_allinfolder
for file in *.pdf; do gs -o "$file" -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -c "<</Orientation 3>> setpagedevice" -f "$file"; done
}


function pdf2txt_OCR() {
# Extracts data from a PDF to a text file using OCR.
# Example: pdf2txt_OCR "document.pdf"
echo "Processing:" $1
tesseract "$1" "$1.txt" -l est
replace_extension jpg.txt.txt txt
}

function pdf2txt_OCR_allin() {
# Extracts data from all PDF files in the current folder, to text files using OCR.
# Example: pdf2txt_OCR_allin
while IFS= read -r file; do
echo "Processing:" $file
output="${file%.*}.txt"   # $output will have a replaced extension
tesseract "$file" "$output" -l est
replace_extension txt.txt txt
done
}


function OCR_recursively_alljpg2txt() {
# Creates .txt files of all found jpg files in current folder AND SUBFOLDERS!
# Example: OCR_recursively_alljpg2txt
find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' \) | while IFS= read -r img; do
txt="${img%.*}.txt"
if [[ ! -f "$txt" ]]; then
  echo "OCR: $img → $txt"
  tesseract "$img" "${img%.*}" -l est &> /dev/null
else
  echo "Skipped (already exists): $txt"
fi
done
}


function resize50() {
# Resizes all image files in current folder AND ITS SUBFOLDERS to -50% image size by overwriting method, meaning shrinking the original images 50% in their resolution, without making any copies.
# Example: resize50 jpg
ext="$1"
if [[ -z "$ext" ]]; then
echo "Resize (make 50% smaller) all jpg, png, webp or other images in current folder AND in the subfolders. NB! It does not create copies, but just overwrites the same images."
echo "Usage example: resize50 jpg"
echo "Usage example: resize50 PNG"
return 1
fi

# Normalize input to lowercase
ext="${ext,,}"

# Build extension patterns
case "$ext" in
  jpg)
    exts=("*.jpg" "*.JPG" "*.jpeg" "*.JPEG")
    ;;
  png)
    exts=("*.png" "*.PNG")
    ;;
  webp)
    exts=("*.webp" "*.WEBP")
    ;;
  *)
    exts=("*.${ext}" "*.${ext^^}")
    ;;
esac

# Build find command dynamically
find_cmd=(find . -type f)
for pattern in "${exts[@]}"; do
find_cmd+=(-iname "$pattern" -o)
done
unset 'find_cmd[${#find_cmd[@]}-1]'  # remove last -o

# Run find and resize each matching file
"${find_cmd[@]}" | while IFS= read -r img; do
echo "Resizing: $img"
convert "$img" -resize 50% "$img"
done
}



# ------------ DOCS PROCESSING ------------

function xlsx2pdf() {
# Converts an excel file to PDF format using LibreOffice engine.
# Example: xlsx2pdf "file.xlsx"
local test=$(which libreoffice)
if [[ $test != "" ]]; then
libreoffice --headless --convert-to pdf "$1"
else
echo "Please make sure to have LibreOffice installed for this function to work."
fi
}

function ods2xlsx() {
# Converts an ODS file to XLSX format using LibreOffice engine.
# Example: ods2xlsx "file.ods"
local test=$(which libreoffice)
if [[ $test != "" ]]; then
libreoffice --headless --convert-to xlsx "$1"
else
echo "Please make sure to have LibreOffice installed for this function to work."
fi
}

function pdf2docx() {
# Converts a PDF file to DOCX format and saves it to a specified folder by using LibreOffice engine.
# Example: pdf2docx file.pdf ~/Desktop/
local file=${1?No input given for the file name}
local folder=${2:-$(pwd)}  # Default to current directory if no output folder is provided
local test=$(which libreoffice)
if [[ $test != "" ]]; then
libreoffice --headless --convert-to docx --outdir "$folder" "$file"
else
echo "Please make sure to have LibreOffice installed for this function to work."
fi
}



function jpg2txt_allincwd() {
# Extracts data into text files from image files or pdf files, inside the current folder.
# Example: jpg2txt_allincwd *.pdf
# Example: jpg2txt_allincwd *.jpg
pattern="${1:-*.jpg}"                               # Check if an argument is passed, otherwise default to *.jpg
for f in $pattern; do pdf2txt_OCR "$f" "$f"; done   # Loop through the files based on the provided pattern
}



# ------------ CRYPTO --------------------

function crypto_fearandgreedindex() {
# Gets the current crypto fear and greed index via API (usable only once a day).
curl -s https://api.alternative.me/fng/ | jq -r '.data[0].value'
}

function qort_price() {
# Gets the current market price of QORT cryptocurrency from TradeOgre using API.
curl -sX GET "https://tradeogre.com/api/v1/markets" | jq -r '.[]["QORT-USDT"].price // empty | tonumber'
}






# ------------ VERSION CHECK / UPDATE ------------

function ba_versioncheck() {
# Checks for a newer version of the BASH Addins library on GitHub. The version check COULD happen automatically on every first day of the month and notification come into Terminal about the update being available. Or manually by running, with the option to auto-update (install automatically) by running "bash.addins update" - this should download the new version from GitHub, make it it executable and overwrite the existing file with the new one. The comparison of the versions should be done on the $ba_version
# If there is a newer (higher) version number in GitHub compared to the one written into the current bash.addins file, then notify the user.
mkdir -p /tmp
echo "Checking GitHub for a newer version..."
curl -s "https://github.com/arrrtto/bash.addins/blob/main/bash.addins" > /tmp/ba.ver
ba_githubversion=$(cat /tmp/ba.ver | grep -oP 'ba_version=........' | grep -oP '\d+.\d+')
rm /tmp/ba.ver
# Compare the versions as arithmetic values...
if [[ "$(printf '%s\n' "$ba_version" "$ba_githubversion" | sort -V | head -n 1)" != "$ba_githubversion" ]]; then
 echo "Newer version of the BASH addins library ($ba_githubversion) available on GitHub."

# ↓-- NEEDS TO BE MADE FUNCTIONAL AT SOME POINT --↓ #
#echo "Do you want to install it now?"
# -- The download and installation process should happen here:
#cd /tmp && wget -q "https://github.com/arrrtto/bash.addins/archive/refs/tags/$ba_githubversion.zip"
#unzip $ba_githubversion.zip && mv /tmp/bash.addins-$ba_githubversion/bash.addins /home/$USER/bin/bash.addins && chmod +x /home/$USER/bin/bash.addins
#cd -
#echo "Downloaded, extracted and moved the newer version to /home/$USER/bin :)"
# ↑-- NEEDS TO BE MADE FUNCTIONAL AT SOME POINT --↑ #

fi
if [[ $ba_githubversion == $ba_version ]]; then
 echo "You have the newest version already :)"
fi

}


# ------------ SETUP ------------

function ba_setup() {
# For setting up the files, folder structure, configurations (paths) and installing software dependencies.
# Sets up .bashrc contents for file and folder paths.
local bashrc_file="$HOME/.bashrc"
local new_lines=$(cat <<EOF
export PATH=\$PATH:/home/\$USER/bin
source bash.addins
EOF
)
if ! grep -q "bash.addins" "$bashrc_file"; then    # Check if the lines already exist to avoid duplicates, and if not, append the lines to .bashrc
echo "$new_lines" >> "$bashrc_file"
echo ".bashrc has been updated with new environment variables."
fi

mkdir -p /home/$USER/bin
if [[ $ba_running_folder != "/home/$USER/bin" ]]; then
cp "$ba_running_folder/bash.addins" "/home/$USER/bin/bash.addins"
chmod +x "/home/$USER/bin/bash.addins"
fi

# Install all the dependencies (should get installed well at least on Debian based systems)
sudo apt install -y qrencode ffmpeg wget libheif1 sane-utils imagemagick ghostscript xdotool curl csvkit imagemagick wmctrl xclip x11-apps tesseract-ocr scrot gnome-screenshot jq python3-full python3-xlsxwriter python3-openpyxl python3-odf python3-pdfkit csvkit html2text docx2txt xlsx2csv mupdf unoconv libreoffice-script-provider-python sox pdftk
}


# ------------ PARAMETERS TO RUN THE LIBRARY FILE WITH ------------
if [[ "$1" == "setup" ]] || [[ "$1" == "--setup" ]]; then ba_setup; fi
if [[ "$1" == "update" ]] || [[ "$1" == "--update" ]]; then ba_versioncheck; fi
if [[ "$1" == "check" ]] || [[ "$1" == "--check" ]]; then ba_versioncheck; fi
if [[ "$1" == "version" ]] || [[ "$1" == "--version" ]] || [[ "$1" == "--ver" ]]; then echo "BASH Addins Library version $ba_version" && sleep 1; fi
if [[ "$1" == "help" ]] || [[ "$1" == "--help" ]]; then
echo "To install all dependencies and get BASH addins custom libarary to function in Terminal, run:"
echo "bash.addins setup"
echo "and make sure everything gets installed - then you are ready to use the custom functions every time you open the Terminal :)"
echo 
echo "To check if a newer version is available, and to install the newer version over the current one, run:"
echo "bash.addins update" 
echo
echo "To display the current version, run:"
echo "bash.addins version"
echo
echo "Once you have the library installed/loaded, you can see the list of functions with:"
echo "showallfunctions"

fi
